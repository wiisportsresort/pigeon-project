import{n as S,s as N,a as G,r as J,i as K,t as x,S as Q,b as V,e as R,d as I,g as P,f as k,h as C,j as E,k as D,c as Z,l as $,m as Y,o as A,p as O,q as X,u as T,v as q,w as H}from"./common/index-32a68b49.js";import{w as ee}from"./common/wrap-aa6f377e.js";const v=[];function M(t,e){return{subscribe:te(t,e).subscribe}}function te(t,e=S){let n;const i=[];function a(s){if(N(t,s)&&(t=s,n)){const r=!v.length;for(let o=0;o<i.length;o+=1){const p=i[o];p[1](),v.push(p,t)}if(r){for(let o=0;o<v.length;o+=2)v[o][0](v[o+1]);v.length=0}}}function l(s){a(s(t))}function f(s,r=S){const o=[s,r];return i.push(o),i.length===1&&(n=e(a)||S),s(t),()=>{const p=i.indexOf(o);p!==-1&&i.splice(p,1),i.length===0&&(n(),n=null)}}return{set:a,update:l,subscribe:f}}function U(t,e,n){const i=!Array.isArray(t),a=i?[t]:t,l=e.length<2;return M(n,f=>{let s=!1;const r=[];let o=0,p=S;const j=()=>{if(o)return;p();const w=e(i?r[0]:r,f);l?f(w):p=K(w)?w:S},b=a.map((w,y)=>G(w,_=>{r[y]=_,o&=~(1<<y),s&&j()},()=>{o|=1<<y}));return s=!0,j(),function(){J(b),p()}})}function ne(t,e){if(t instanceof RegExp)return{keys:!1,pattern:t};var n,i,a,l,f=[],s="",r=t.split("/");for(r[0]||r.shift();a=r.shift();)n=a[0],n==="*"?(f.push("wild"),s+="/(.*)"):n===":"?(i=a.indexOf("?",1),l=a.indexOf(".",1),f.push(a.substring(1,~i?i:~l?l:a.length)),s+=!!~i&&!~l?"(?:/([^/]+?))?":"/([^/]+?)",~l&&(s+=(~i?"?":"")+"\\"+a.substring(l))):s+="/"+a;return{keys:f,pattern:new RegExp("^"+s+(e?"(?=$|/)":"/?$"),"i")}}function se(t){let e,n,i;const a=[t[2]];var l=t[0];function f(s){let r={};for(let o=0;o<a.length;o+=1)r=H(r,a[o]);return{props:r}}return l&&(e=new l(f()),e.$on("routeEvent",t[7])),{c(){e&&A(e.$$.fragment),n=R()},m(s,r){e&&O(e,s,r),I(s,n,r),i=!0},p(s,r){const o=r&4?X(a,[T(s[2])]):{};if(l!==(l=s[0])){if(e){P();const p=e;k(p.$$.fragment,1,0,()=>{q(p,1)}),C()}l?(e=new l(f()),e.$on("routeEvent",s[7]),A(e.$$.fragment),E(e.$$.fragment,1),O(e,n.parentNode,n)):e=null}else l&&e.$set(o)},i(s){i||(e&&E(e.$$.fragment,s),i=!0)},o(s){e&&k(e.$$.fragment,s),i=!1},d(s){s&&D(n),e&&q(e,s)}}}function re(t){let e,n,i;const a=[{params:t[1]},t[2]];var l=t[0];function f(s){let r={};for(let o=0;o<a.length;o+=1)r=H(r,a[o]);return{props:r}}return l&&(e=new l(f()),e.$on("routeEvent",t[6])),{c(){e&&A(e.$$.fragment),n=R()},m(s,r){e&&O(e,s,r),I(s,n,r),i=!0},p(s,r){const o=r&6?X(a,[r&2&&{params:s[1]},r&4&&T(s[2])]):{};if(l!==(l=s[0])){if(e){P();const p=e;k(p.$$.fragment,1,0,()=>{q(p,1)}),C()}l?(e=new l(f()),e.$on("routeEvent",s[6]),A(e.$$.fragment),E(e.$$.fragment,1),O(e,n.parentNode,n)):e=null}else l&&e.$set(o)},i(s){i||(e&&E(e.$$.fragment,s),i=!0)},o(s){e&&k(e.$$.fragment,s),i=!1},d(s){s&&D(n),e&&q(e,s)}}}function ie(t){let e,n,i,a;const l=[re,se],f=[];function s(r,o){return r[1]?0:1}return e=s(t),n=f[e]=l[e](t),{c(){n.c(),i=R()},m(r,o){f[e].m(r,o),I(r,i,o),a=!0},p(r,[o]){let p=e;e=s(r),e===p?f[e].p(r,o):(P(),k(f[p],1,1,()=>{f[p]=null}),C(),n=f[e],n?n.p(r,o):(n=f[e]=l[e](r),n.c()),E(n,1),n.m(i.parentNode,i))},i(r){a||(E(n),a=!0)},o(r){k(n),a=!1},d(r){f[e].d(r),r&&D(i)}}}function oe(t,e,...n){return console.warn("Method `wrap` from `svelte-spa-router` is deprecated and will be removed in a future version. Please use `svelte-spa-router/wrap` instead. See http://bit.ly/svelte-spa-router-upgrading"),ee({component:t,userData:e,conditions:n})}function F(){const t=window.location.href.indexOf("#/");let e=t>-1?window.location.href.substr(t+1):"/";const n=e.indexOf("?");let i="";return n>-1&&(i=e.substr(n+1),e=e.substr(0,n)),{location:e,querystring:i}}const L=M(null,function(e){e(F());const n=()=>{e(F())};return window.addEventListener("hashchange",n,!1),function(){window.removeEventListener("hashchange",n,!1)}}),ae=U(L,t=>t.location),le=U(L,t=>t.querystring);async function ce(t){if(!t||t.length<1||t.charAt(0)!="/"&&t.indexOf("#/")!==0)throw Error("Invalid parameter location");await x(),history.replaceState({scrollX:window.scrollX,scrollY:window.scrollY},void 0,void 0),window.location.hash=(t.charAt(0)=="#"?"":"#")+t}async function ue(){await x(),window.history.back()}async function fe(t){if(!t||t.length<1||t.charAt(0)!="/"&&t.indexOf("#/")!==0)throw Error("Invalid parameter location");await x();const e=(t.charAt(0)=="#"?"":"#")+t;try{window.history.replaceState(void 0,void 0,e)}catch(n){console.warn("Caught exception while replacing the current page. If you're running this in the Svelte REPL, please note that the `replace` method might not work in this environment.")}window.dispatchEvent(new Event("hashchange"))}function he(t,e){if(!t||!t.tagName||t.tagName.toLowerCase()!="a")throw Error('Action "link" can only be used with <a> tags');return W(t,e||t.getAttribute("href")),{update(n){W(t,n)}}}function W(t,e){if(!e||e.length<1||e.charAt(0)!="/")throw Error('Invalid value for "href" attribute: '+e);t.setAttribute("href","#"+e),t.addEventListener("click",pe)}function pe(t){t.preventDefault();const e=t.currentTarget.getAttribute("href");history.replaceState({scrollX:window.scrollX,scrollY:window.scrollY},void 0,void 0),window.location.hash=e}function de(t,e,n){let{routes:i={}}=e,{prefix:a=""}=e,{restoreScrollState:l=!1}=e;class f{constructor(c,h){if(!h||typeof h!="function"&&(typeof h!="object"||h._sveltesparouter!==!0))throw Error("Invalid component object");if(!c||typeof c=="string"&&(c.length<1||c.charAt(0)!="/"&&c.charAt(0)!="*")||typeof c=="object"&&!(c instanceof RegExp))throw Error('Invalid value for "path" argument - strings must start with / or *');const{pattern:g,keys:d}=ne(c);this.path=c,typeof h=="object"&&h._sveltesparouter===!0?(this.component=h.component,this.conditions=h.conditions||[],this.userData=h.userData,this.props=h.props||{}):(this.component=()=>Promise.resolve(h),this.conditions=[],this.props={}),this._pattern=g,this._keys=d}match(c){if(a){if(typeof a=="string")if(c.startsWith(a))c=c.substr(a.length)||"/";else return null;else if(a instanceof RegExp){const m=c.match(a);if(m&&m[0])c=c.substr(m[0].length)||"/";else return null}}const h=this._pattern.exec(c);if(h===null)return null;if(this._keys===!1)return h;const g={};let d=0;for(;d<this._keys.length;){try{g[this._keys[d]]=decodeURIComponent(h[d+1]||"")||null}catch(m){g[this._keys[d]]=null}d++}return g}async checkConditions(c){for(let h=0;h<this.conditions.length;h++)if(!await this.conditions[h](c))return!1;return!0}}const s=[];i instanceof Map?i.forEach((u,c)=>{s.push(new f(c,u))}):Object.keys(i).forEach(u=>{s.push(new f(u,i[u]))});let r=null,o=null,p={};const j=Z();async function b(u,c){await x(),j(u,c)}let w=null;l&&(window.addEventListener("popstate",u=>{u.state&&u.state.scrollY?w=u.state:w=null}),$(()=>{w?window.scrollTo(w.scrollX,w.scrollY):window.scrollTo(0,0)}));let y=null,_=null;L.subscribe(async u=>{y=u;let c=0;for(;c<s.length;){const h=s[c].match(u.location);if(!h){c++;continue}const g={route:s[c].path,location:u.location,querystring:u.querystring,userData:s[c].userData};if(!await s[c].checkConditions(g)){n(0,r=null),_=null,b("conditionsFailed",g);return}b("routeLoading",Object.assign({},g));const d=s[c].component;if(_!=d){d.loading?(n(0,r=d.loading),_=d,n(1,o=d.loadingParams),n(2,p={}),b("routeLoaded",Object.assign({},g,{component:r,name:r.name}))):(n(0,r=null),_=null);const m=await d();if(u!=y)return;n(0,r=m&&m.default||m),_=d}h&&typeof h=="object"&&Object.keys(h).length?n(1,o=h):n(1,o=null),n(2,p=s[c].props),b("routeLoaded",Object.assign({},g,{component:r,name:r.name}));return}n(0,r=null),_=null});function z(u){Y(t,u)}function B(u){Y(t,u)}return t.$$set=u=>{"routes"in u&&n(3,i=u.routes),"prefix"in u&&n(4,a=u.prefix),"restoreScrollState"in u&&n(5,l=u.restoreScrollState)},t.$$.update=()=>{t.$$.dirty&32&&(history.scrollRestoration=l?"manual":"auto")},[r,o,p,i,a,l,z,B]}class we extends Q{constructor(e){super();V(this,e,de,ie,N,{routes:3,prefix:4,restoreScrollState:5})}}export default we;export{he as link,L as loc,ae as location,ue as pop,ce as push,le as querystring,fe as replace,oe as wrap};
